<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>caedmon</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://caedmonjiang.github.io//favicon.ico?v=1565230474626">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://caedmonjiang.github.io//styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://caedmonjiang.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://caedmonjiang.github.io//images/avatar.png?v=1565230474626" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">caedmon</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-master-%E8%8A%82%E7%82%B9">一、 master 节点</a>
<ul>
<li><a href="#11-%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99-selinux%E5%92%8Cswap">1.1 禁用防火墙、selinux和swap</a></li>
<li><a href="#12-%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%B0%86%E6%A1%A5%E6%8E%A5%E7%9A%84ipv4%E6%B5%81%E9%87%8F%E4%BC%A0%E9%80%92%E5%88%B0iptables%E7%9A%84%E9%93%BE">1.2 配置内核参数，将桥接的IPv4流量传递到iptables的链</a></li>
<li><a href="#13-%E9%85%8D%E7%BD%AEdocker%E6%BA%90">1.3 配置docker源</a></li>
<li><a href="#14-%E9%85%8D%E7%BD%AE-kubernetes-%E6%BA%90">1.4 配置 kubernetes 源</a></li>
<li><a href="#15-%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E7%A8%8B%E5%BA%8F%E5%8C%85docker-ce-kubelet-kubeadm-kubectl">1.5 安装相关程序包（docker-ce kubelet kubeadm kubectl）：</a></li>
<li><a href="#16-%E8%AE%BE%E7%BD%AEdocker%E5%92%8Ckubelet%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8">1.6 设置docker和kubelet开机自启动</a></li>
<li><a href="#17-%E8%AE%BE%E7%BD%AE-docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8">1.7 设置 docker 镜像加速器</a></li>
<li><a href="#18-%E5%90%AF%E5%8A%A8-kubeadm-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%BD%E4%BB%A4">1.8 启动 kubeadm 初始化命令</a></li>
<li><a href="#19-%E6%A0%B9%E6%8D%AE-kubeadm-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84%E6%8F%90%E7%A4%BA%E6%89%A7%E8%A1%8C%E4%BB%A5%E4%B8%8B%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE-kubectl-%E5%B7%A5%E5%85%B7">1.9 根据 kubeadm 初始化命令的输出信息中的提示，执行以下命令配置 kubectl 工具：</a></li>
<li><a href="#110-%E6%AD%A4%E6%97%B6%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81">1.10 此时，可以查看一些状态：</a></li>
<li><a href="#111-%E9%83%A8%E7%BD%B2-flannel-%E7%BD%91%E7%BB%9C">1.11 部署 flannel 网络</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-node-%E8%8A%82%E7%82%B9">二、node 节点</a>
<ul>
<li><a href="#21-%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99-selinux%E5%92%8Cswap">2.1 禁用防火墙、selinux和swap</a></li>
<li><a href="#22-%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%B0%86%E6%A1%A5%E6%8E%A5%E7%9A%84ipv4%E6%B5%81%E9%87%8F%E4%BC%A0%E9%80%92%E5%88%B0iptables%E7%9A%84%E9%93%BE">2.2 配置内核参数，将桥接的IPv4流量传递到iptables的链</a></li>
<li><a href="#23-%E9%85%8D%E7%BD%AEdocker%E6%BA%90">2.3 配置docker源</a></li>
<li><a href="#24-%E9%85%8D%E7%BD%AE-kubernetes-%E6%BA%90">2.4 配置 kubernetes 源</a></li>
<li><a href="#25-%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E7%A8%8B%E5%BA%8F%E5%8C%85docker-ce-kubelet-kubeadm-kubectl">2.5 安装相关程序包（docker-ce kubelet kubeadm kubectl）：</a></li>
<li><a href="#26-%E8%AE%BE%E7%BD%AEdocker%E5%92%8Ckubelet%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8">2.6 设置docker和kubelet开机自启动</a></li>
<li><a href="#27-%E8%AE%BE%E7%BD%AE-docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8">2.7 设置 docker 镜像加速器</a></li>
<li><a href="#28-%E6%89%A7%E8%A1%8C%E5%8A%A0%E5%85%A5-node-%E8%8A%82%E7%82%B9%E7%9A%84%E5%91%BD%E4%BB%A4%E6%AD%A4%E5%A4%84%E7%9A%84-token-%E5%92%8C-sha256-%E5%8F%AF%E5%9C%A8-master-%E4%B8%8A%E6%89%A7%E8%A1%8C-kubeadm-init-%E5%91%BD%E5%90%8D%E5%90%8E%E7%9A%84%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E4%B8%AD%E5%BE%97%E5%88%B0">2.8 执行加入 node 节点的命令（此处的 token 和 sha256 可在 master 上执行 kubeadm init 命名后的输出内容中得到）：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E4%B8%BA-k8s-%E9%9B%86%E7%BE%A4%E6%96%B0%E5%A2%9E-node-%E8%8A%82%E7%82%B9">三、为 K8S 集群新增 node 节点</a></li>
<li><a href="#%E5%9B%9B-%E9%83%A8%E7%BD%B2-dashboard">四、部署 Dashboard</a>
<ul>
<li><a href="#41-%E5%88%9B%E5%BB%BA-dashboard-%E7%9A%84-yaml-%E6%96%87%E4%BB%B6">4.1 创建 Dashboard 的 yaml 文件</a></li>
<li><a href="#42-%E4%BF%AE%E6%94%B9-dashboard-%E7%9A%84-yaml-%E6%96%87%E4%BB%B6">4.2 修改 Dashboard 的 yaml 文件</a></li>
<li><a href="#43-%E9%83%A8%E7%BD%B2-dashboard">4.3 部署 Dashboard</a></li>
<li><a href="#44-%E6%A3%80%E6%9F%A5-dashboard-%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81">4.4 检查 Dashboard 服务运行状态</a></li>
<li><a href="#45-%E5%88%9B%E5%BB%BA%E8%B4%A6%E5%8F%B7%E7%99%BB%E9%99%86">4.5 创建账号登陆</a></li>
<li><a href="#46-%E4%BD%BF%E7%94%A8%E4%B8%8A%E4%B8%80%E6%AD%A5%E5%BE%97%E5%88%B0%E7%9A%84-token-%E7%99%BB%E9%99%86-dashboard">4.6 使用上一步得到的 token 登陆 Dashboard</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://caedmonjiang.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">K8S安装步骤</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-08-07 / 4 min read
        </div>
        
        <div class="post-content yue">
          <h2 id="一-master-节点">一、 master 节点</h2>
<h3 id="11-禁用防火墙-selinux和swap">1.1 禁用防火墙、selinux和swap</h3>
<pre><code>systemctl stop firewalld
systemctl disable firewalld
setenforce 0
sed -i &quot;s/^SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config
swapoff -a
sed -i 's/.*swap.*/#&amp;/' /etc/fstab
</code></pre>
<h3 id="12-配置内核参数将桥接的ipv4流量传递到iptables的链">1.2 配置内核参数，将桥接的IPv4流量传递到iptables的链</h3>
<pre><code>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
</code></pre>
<p>查看命令</p>
<pre><code>sysctl --system
</code></pre>
<h3 id="13-配置docker源">1.3 配置docker源</h3>
<pre><code>wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo
</code></pre>
<h3 id="14-配置-kubernetes-源">1.4 配置 kubernetes 源</h3>
<pre><code>cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
</code></pre>
<h3 id="15-安装相关程序包docker-ce-kubelet-kubeadm-kubectl">1.5 安装相关程序包（docker-ce kubelet kubeadm kubectl）：</h3>
<pre><code>yum install -y docker-ce kubelet kubeadm kubectl
</code></pre>
<h3 id="16-设置docker和kubelet开机自启动">1.6 设置docker和kubelet开机自启动</h3>
<pre><code>systemctl enable docker kubelet
</code></pre>
<h3 id="17-设置-docker-镜像加速器">1.7 设置 docker 镜像加速器</h3>
<pre><code>sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://dry9722u.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<h3 id="18-启动-kubeadm-初始化命令">1.8 启动 kubeadm 初始化命令</h3>
<pre><code>kubeadm init --pod-network-cidr=10.244.0.0/16 \
--service-cidr=10.96.0.0/16 \
--image-repository registry.aliyuncs.com/google_containers 
</code></pre>
<p>--image-repository 参数很关键，由于kubeadm 默认从官网k8s.grc.io下载所需镜像，国内无法访问，因此需要通过–image-repository指定阿里云镜像仓库地址。</p>
<p>如果命令执行成功，会得到如下的输出（<strong>一定要保存好 kubeadm join ... 这一串内容，后续配置 node 节点会用到</strong>）：</p>
<pre><code>Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 172.16.131.129:6443 --token srzvhr.e56rb9ceb8c6idaf \
    --discovery-token-ca-cert-hash sha256:69f2fd9fd889300635f094ef1c954d2eddde08e974cbd2b278393f2c5115709d
</code></pre>
<h3 id="19-根据-kubeadm-初始化命令的输出信息中的提示执行以下命令配置-kubectl-工具">1.9 根据 kubeadm 初始化命令的输出信息中的提示，执行以下命令配置 kubectl 工具：</h3>
<pre><code>mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="110-此时可以查看一些状态">1.10 此时，可以查看一些状态：</h3>
<p>查看各组件运行状态： kubectl get cs  （kubectl get componentstatus）,得到如下输出</p>
<pre><code># kubectl get cs
NAME                 STATUS    MESSAGE             ERROR
scheduler            Healthy   ok
controller-manager   Healthy   ok
etcd-0               Healthy   {&quot;health&quot;:&quot;true&quot;}
</code></pre>
<p>查看节点信息： kubectl get nodes，得到如下输出</p>
<pre><code># kubectl get nodes
NAME          STATUS     ROLES    AGE   VERSION
centos7-129   NotReady   master   30m   v1.14.3
</code></pre>
<h3 id="111-部署-flannel-网络">1.11 部署 flannel 网络</h3>
<p>可以看到 master 的状态为 <strong>NotReady</strong>，是因为还差一个重要的工具：flannel。</p>
<p>执行以下命令安装 flannel</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre>
<p>等待几分钟后再执行 <code>kubectl get nodes</code>，可以看到 master 的状态已经为 <strong>Ready</strong></p>
<pre><code># kubectl get nodes
NAME          STATUS   ROLES    AGE   VERSION
centos7-129   Ready    master   63m   v1.14.3
</code></pre>
<p>master 节点配置完成！</p>
<h2 id="二-node-节点">二、node 节点</h2>
<h3 id="21-禁用防火墙-selinux和swap">2.1 禁用防火墙、selinux和swap</h3>
<pre><code>systemctl stop firewalld
systemctl disable firewalld
setenforce 0
sed -i &quot;s/^SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config
swapoff -a
sed -i 's/.*swap.*/#&amp;/' /etc/fstab
</code></pre>
<h3 id="22-配置内核参数将桥接的ipv4流量传递到iptables的链">2.2 配置内核参数，将桥接的IPv4流量传递到iptables的链</h3>
<pre><code>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
</code></pre>
<p>查看命令</p>
<pre><code>sysctl --system
</code></pre>
<h3 id="23-配置docker源">2.3 配置docker源</h3>
<pre><code>wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo
</code></pre>
<h3 id="24-配置-kubernetes-源">2.4 配置 kubernetes 源</h3>
<pre><code>cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
</code></pre>
<h3 id="25-安装相关程序包docker-ce-kubelet-kubeadm-kubectl">2.5 安装相关程序包（docker-ce kubelet kubeadm kubectl）：</h3>
<pre><code>yum install -y docker-ce kubelet kubeadm
</code></pre>
<h3 id="26-设置docker和kubelet开机自启动">2.6 设置docker和kubelet开机自启动</h3>
<pre><code>systemctl enable docker kubelet
</code></pre>
<h3 id="27-设置-docker-镜像加速器">2.7 设置 docker 镜像加速器</h3>
<pre><code>sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://dry9722u.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<h3 id="28-执行加入-node-节点的命令此处的-token-和-sha256-可在-master-上执行-kubeadm-init-命名后的输出内容中得到">2.8 执行加入 node 节点的命令（此处的 token 和 sha256 可在 master 上执行 kubeadm init 命名后的输出内容中得到）：</h3>
<pre><code>kubeadm join 192.168.1.8:6443 --token 4y1nlo.xcnog77gl7jqz3cq \
    --discovery-token-ca-cert-hash sha256:d5b3ca5ceea84d321aaa2ca43317ed53fdf430afdc447cb76295d2ac7f914e84 --ignore-preflight-errors=Swap
</code></pre>
<h1 id="三-为-k8s-集群新增-node-节点">三、为 K8S 集群新增 node 节点</h1>
<p>K8S 的 apiserver 发出的 token 有效期只有1天，在 token 过期的情况下或者忘记 token 的情况下，可以通过如下脚本来获取将新 node 节点加入到 K8S 集群中的命令。</p>
<p>1). 创建一个 bash 脚本，如 gen_join_command.sh<br>
具体代码如下：</p>
<pre><code class="language-bash">#!/bin/bash

if [ $EUID -ne 0 ];then
    echo &quot;You must be root (or sudo) to run this script&quot;
    exit 1
fi

if [ $# != 1 ] ; then
    echo &quot;Usage: $0 [master-hostname | master-ip-address]&quot;
    echo &quot; e.g.: $0 api.k8s.hiko.im&quot;
    exit 1;
fi

token=`kubeadm token create`
cert_hash=`openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'`

echo &quot;Refer the following command to join kubernetes cluster:&quot;
echo &quot;kubeadm join $1:6443 --token ${token} --discovery-token-ca-cert-hash sha256:${cert_hash} --ignore-preflight-errors=Swap&quot;
</code></pre>
<p>2). 授予脚本的执行权限</p>
<pre><code>chmod +x ./gen_join_command.sh
</code></pre>
<p>3). 执行脚本 <code>gen_join_command.sh [master 节点的IP 或者 域名]</code>， 如：</p>
<pre><code>./gen_join_command.sh 192.168.1.8
</code></pre>
<p>4). 复制上一步的命令执行后得到的输出 “kubeadm join ...”<br>
5). 将复制的语句在要新加的 node 节点服务器上执行即可。</p>
<h1 id="四-部署-dashboard">四、部署 Dashboard</h1>
<p>在 master 节点上部署。</p>
<h2 id="41-创建-dashboard-的-yaml-文件">4.1 创建 Dashboard 的 yaml 文件</h2>
<pre><code>wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml
</code></pre>
<p>Dashboard 的 github 地址： https://github.com/kubernetes/dashboard</p>
<p>可在 github 上查看最新版本信息。</p>
<h2 id="42-修改-dashboard-的-yaml-文件">4.2 修改 Dashboard 的 yaml 文件</h2>
<ol>
<li>由于源文件中的 Dashboard 镜像在国内会被墙，所以要将 Dashboard 的镜像修改为国内网络可以拉取到的镜像。</li>
<li>修改为 NodePort 的方式暴露服务，以便可以直接通过主机地址访问。</li>
</ol>
<pre><code>sed -i 's/k8s.gcr.io/loveone/g' kubernetes-dashboard.yaml
sed -i '/targetPort:/a\ \ \ \ \ \ nodePort: 30001\n\ \ type: NodePort' kubernetes-dashboard.yaml
</code></pre>
<h2 id="43-部署-dashboard">4.3 部署 Dashboard</h2>
<pre><code>kubectl apply -f kubernetes-dashboard.yaml
</code></pre>
<h2 id="44-检查-dashboard-服务运行状态">4.4 检查 Dashboard 服务运行状态</h2>
<pre><code>kubectl get deployment kubernetes-dashboard -n kube-system
kubectl get pods -n kube-system -o wide
kubectl get services -n kube-system
</code></pre>
<p>在浏览器中访问 Dashboard ： https:192.168.1.8:30001<br>
注意： 是 https !</p>
<h2 id="45-创建账号登陆">4.5 创建账号登陆</h2>
<pre><code>kubectl create serviceaccount  dashboard-admin -n kube-system
kubectl create clusterrolebinding  dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin
kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/{print $1}')
</code></pre>
<h2 id="46-使用上一步得到的-token-登陆-dashboard">4.6 使用上一步得到的 token 登陆 Dashboard</h2>
<p><img src="leanote://file/getImage?fileId=5d0c737b690e1a6056000001" alt="登陆界面"></p>
<p>登陆后即可看到 Dashboard 首页。如下图：<br>
<img src="leanote://file/getImage?fileId=5d0c73fd690e1a6056000002" alt="首页界面"></p>

        </div>

        


        <div class="flex justify-between py-8">
          

          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '8711f03afc9facae9797',
    clientSecret: '141fdcfc88d171718788020005c869313bc24930',
    repo: 'caedmonjiang.github.io',
    owner: 'caedmonjiang',
    admin: ['caedmonjiang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
